// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Int = require("bs-platform/lib/js/belt_Int.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");

function isNumeric(character) {
  switch (character) {
    case "0" :
    case "1" :
    case "2" :
    case "3" :
    case "4" :
    case "5" :
    case "6" :
    case "7" :
    case "8" :
    case "9" :
        return true;
    default:
      return false;
  }
}

function isAlphabetical(character) {
  switch (character) {
    case "A" :
    case "B" :
    case "C" :
    case "D" :
    case "E" :
    case "F" :
    case "G" :
    case "H" :
    case "I" :
    case "J" :
    case "K" :
    case "L" :
    case "M" :
    case "N" :
    case "O" :
    case "P" :
    case "Q" :
    case "R" :
    case "S" :
    case "T" :
    case "U" :
    case "V" :
    case "W" :
    case "X" :
    case "Y" :
    case "Z" :
    case "a" :
    case "b" :
    case "c" :
    case "d" :
    case "e" :
    case "f" :
    case "g" :
    case "h" :
    case "i" :
    case "j" :
    case "k" :
    case "l" :
    case "m" :
    case "n" :
    case "o" :
    case "p" :
    case "q" :
    case "r" :
    case "s" :
    case "t" :
    case "u" :
    case "v" :
    case "w" :
    case "x" :
    case "y" :
    case "z" :
        return true;
    default:
      return false;
  }
}

function isAlphanumeric(character) {
  if (isNumeric(character)) {
    return true;
  } else {
    return isAlphabetical(character);
  }
}

function parseLetType(_buffer, _code) {
  while(true) {
    var code = _code;
    var buffer = _buffer;
    if (!code) {
      return ;
    }
    var tail = code.tl;
    var head = code.hd;
    if (isAlphanumeric(head)) {
      _code = tail;
      _buffer = buffer + head;
      continue ;
    }
    if (buffer === "" && head === " ") {
      _code = tail;
      _buffer = "";
      continue ;
    }
    if (head === " ") {
      return [
              buffer,
              tail
            ];
    }
    console.log("Unexpected", head, "when parsing let type");
    return ;
  };
}

function parseLetEquals(_buffer, _code) {
  while(true) {
    var code = _code;
    var buffer = _buffer;
    if (!code) {
      return ;
    }
    var head = code.hd;
    if (buffer === "") {
      if (head === " ") {
        _code = code.tl;
        _buffer = "";
        continue ;
      }
      console.log("Unexpected", head, "when parsing let equals");
      return ;
    }
    console.log("Unexpected", head, "when parsing let equals");
    return ;
  };
}

function parseBlock(_buffer, _code) {
  while(true) {
    var code = _code;
    var buffer = _buffer;
    if (!code) {
      return ;
    }
    var tail = code.tl;
    var head = code.hd;
    var exit = 0;
    var word;
    var exit$1 = 0;
    var exit$2 = 0;
    if (isAlphanumeric(head)) {
      _code = tail;
      _buffer = buffer + head;
      continue ;
    }
    switch (buffer) {
      case "" :
          switch (head) {
            case "\n" :
            case " " :
                _code = tail;
                _buffer = "";
                continue ;
            case "{" :
                console.log("OPEN BLOCK");
                _code = tail;
                _buffer = "";
                continue ;
            case "}" :
                console.log("CLOSE BLOCK");
                _code = tail;
                _buffer = "";
                continue ;
            default:
              exit = 1;
          }
          break;
      case "if" :
          if (head === "(") {
            word = buffer;
            exit = 2;
          } else {
            exit$2 = 4;
          }
          break;
      case "return" :
          if (head === ";") {
            word = buffer;
            exit = 2;
          } else {
            exit$2 = 4;
          }
          break;
      default:
        exit$1 = 3;
    }
    if (exit$2 === 4) {
      if (head === "\n") {
        word = buffer;
        exit = 2;
      } else {
        exit$1 = 3;
      }
    }
    if (exit$1 === 3) {
      var exit$3 = 0;
      switch (buffer) {
        case "if" :
        case "let" :
        case "return" :
            exit$3 = 4;
            break;
        default:
          exit = 1;
      }
      if (exit$3 === 4) {
        if (head === " ") {
          word = buffer;
          exit = 2;
        } else {
          exit = 1;
        }
      }
      
    }
    switch (exit) {
      case 1 :
          console.log("Unexpected", head, "when parsing word", buffer);
          return ;
      case 2 :
          switch (word) {
            case "if" :
                console.log("IF");
                return parseIf("", code);
            case "let" :
                console.log("LET");
                return parseLet("", tail);
            case "return" :
                console.log("RETURN");
                _code = tail;
                _buffer = "";
                continue ;
            default:
              console.log("Word(" + word + ")");
              _code = tail;
              _buffer = "";
              continue ;
          }
      
    }
  };
}

function parseIf(_buffer, _code) {
  while(true) {
    var code = _code;
    var buffer = _buffer;
    if (!code) {
      return ;
    }
    var tail = code.tl;
    var head = code.hd;
    if (buffer === "") {
      switch (head) {
        case " " :
        case "(" :
            _code = tail;
            _buffer = "";
            continue ;
        default:
          
      }
    }
    if (isAlphanumeric(head)) {
      _code = tail;
      _buffer = buffer + head;
      continue ;
    }
    switch (head) {
      case " " :
          console.log("Word(" + buffer + ")");
          return ;
      case ")" :
          console.log("Word(" + buffer + ")\nENDIF");
          return parseBlock("", tail);
      case "." :
          console.log("NamespaceOrObject(" + buffer + ")\nDOT");
          _code = tail;
          _buffer = "";
          continue ;
      default:
        console.log("Non alphanumeric in IF.", head);
        return ;
    }
  };
}

function parseLet(_buffer, _code) {
  while(true) {
    var code = _code;
    var buffer = _buffer;
    if (!code) {
      return ;
    }
    var tail = code.tl;
    var head = code.hd;
    if (isAlphanumeric(head)) {
      _code = tail;
      _buffer = buffer + head;
      continue ;
    }
    switch (head) {
      case " " :
          console.log("Word(" + buffer + ")");
          return ;
      case ")" :
          console.log("Word(" + buffer + ")\nENDIF");
          return parseBlock("", tail);
      case "." :
          console.log("NamespaceOrObject(" + buffer + ")\nDOT");
          _code = tail;
          _buffer = "";
          continue ;
      case ":" :
          console.log("Word(" + buffer + ")");
          var match = parseLetType("", tail);
          if (match !== undefined) {
            console.log("TYPE(" + match[0] + ")");
          } else {
            console.log("Could not parse let type");
          }
          return ;
      default:
        console.log("Unexpected", head, "when parsing let word", buffer);
        return ;
    }
  };
}

function parseCode(codeStr) {
  var code = Belt_List.fromArray(Array.from(codeStr, (function (x) {
              return x;
            })));
  return parseBlock("", code);
}

function strToTokenList(codeStr) {
  return Belt_List.fromArray(Array.from(codeStr, (function (x) {
                    return x;
                  })));
}

function expressionStateToString(state) {
  if (typeof state === "number") {
    switch (state) {
      case /* WaitingTerminateString */0 :
          return "WaitingTerminateString";
      case /* ExpectingCloseBracketOrExpression */1 :
          return "ExpectingCloseBracketOrExpression";
      case /* ExpectingCloseBracketOrFunctionArguments */2 :
          return "ExpectingCloseBracketOrFunctionArguments";
      case /* WaitingOperation */3 :
          return "WaitingOperation";
      
    }
  } else {
    switch (state.TAG | 0) {
      case /* ExpressionStart */0 :
          return "ExpressionStart";
      case /* ExpectingWord */1 :
          return "ExpectingWord";
      case /* ProcessingWordOrExpression */2 :
          return "ProcessingWordOrExpression";
      case /* WaitingTerminateWord */3 :
          return "WaitingTerminateWord";
      case /* WaitingTerminateNumber */4 :
          return "WaitingTerminateNumber";
      case /* ExpectingExpressionEndOrOperator */5 :
          return "ExpectingExpressionEndOrOperator";
      
    }
  }
}

function isTerminatingCharacter(terminationList, character) {
  console.log("isTerminatingCharacter", terminationList, character);
  var result = Belt_List.someU(Belt_Option.mapWithDefaultU(terminationList, /* [] */0, (function (terminationToken) {
              return terminationToken;
            })), (function (terminationToken) {
          return character === terminationToken;
        }));
  console.log(result);
  return result;
}

function isOperator(character) {
  switch (character) {
    case "*" :
    case "+" :
    case "-" :
    case "/" :
        return true;
    default:
      return false;
  }
}

function parseExpression(buffer, code, finalTerminatingTokens) {
  var innerParseExpression = function (_buffer, _code, _state, _stack, _parsedTokens) {
    while(true) {
      var parsedTokens = _parsedTokens;
      var stack = _stack;
      var state = _state;
      var code = _code;
      var buffer = _buffer;
      console.log(expressionStateToString(state), Belt_List.length(code));
      if (code) {
        var tail = code.tl;
        var head = code.hd;
        var exit = 0;
        var exit$1 = 0;
        if (typeof state === "number") {
          switch (state) {
            case /* WaitingTerminateString */0 :
                if (state === 0) {
                  if (head !== "\"") {
                    return innerParseExpression(buffer + head, tail, /* WaitingTerminateString */0, stack, parsedTokens);
                  }
                  console.log("STRING(" + buffer + ")");
                  return innerParseExpression("", tail, Belt_List.headExn(stack), Belt_List.tailExn(stack), {
                              hd: {
                                TAG: /* String */2,
                                _0: buffer
                              },
                              tl: parsedTokens
                            });
                }
                console.log("state:", expressionStateToString(state));
                console.log("Buffer:", buffer);
                console.log("Head:", head);
                return ;
            case /* ExpectingCloseBracketOrExpression */1 :
                exit$1 = 3;
                break;
            case /* ExpectingCloseBracketOrFunctionArguments */2 :
                if (state === 2 && buffer === "") {
                  switch (head) {
                    case " " :
                        return innerParseExpression("", tail, /* ExpectingCloseBracketOrFunctionArguments */2, stack, parsedTokens);
                    case ")" :
                        console.log("CLOSEBRACKET");
                        return innerParseExpression("", tail, Belt_List.headExn(stack), Belt_List.tailExn(stack), {
                                    hd: /* ClosedBracket */1,
                                    tl: parsedTokens
                                  });
                    case "," :
                        console.log("COMMA");
                        return innerParseExpression("", tail, /* ExpectingCloseBracketOrFunctionArguments */2, stack, {
                                    hd: /* Comma */3,
                                    tl: parsedTokens
                                  });
                    default:
                      if (isAlphabetical(head)) {
                        console.log("FUNCTION PARSE EXPRESSION");
                        return innerParseExpression("", {
                                    hd: head,
                                    tl: tail
                                  }, {
                                    TAG: /* ExpressionStart */0,
                                    _0: {
                                      hd: ",",
                                      tl: {
                                        hd: ")",
                                        tl: /* [] */0
                                      }
                                    }
                                  }, {
                                    hd: /* ExpectingCloseBracketOrFunctionArguments */2,
                                    tl: stack
                                  }, parsedTokens);
                      }
                      if (isNumeric(head)) {
                        return innerParseExpression("", {
                                    hd: head,
                                    tl: tail
                                  }, {
                                    TAG: /* ExpressionStart */0,
                                    _0: {
                                      hd: ",",
                                      tl: {
                                        hd: ")",
                                        tl: /* [] */0
                                      }
                                    }
                                  }, {
                                    hd: /* ExpectingCloseBracketOrFunctionArguments */2,
                                    tl: stack
                                  }, parsedTokens);
                      }
                      
                  }
                }
                console.log("state:", expressionStateToString(state));
                console.log("Buffer:", buffer);
                console.log("Head:", head);
                return ;
            case /* WaitingOperation */3 :
                break;
            
          }
        } else {
          switch (state.TAG | 0) {
            case /* ExpressionStart */0 :
                var terminatingTokens = state._0;
                if (buffer === "") {
                  var exit$2 = 0;
                  if (head === "(" && !isTerminatingCharacter(terminatingTokens, "(")) {
                    console.log("OPENBRACKET");
                    _parsedTokens = {
                      hd: /* OpenBracket */0,
                      tl: parsedTokens
                    };
                    _stack = {
                      hd: {
                        TAG: /* ExpectingExpressionEndOrOperator */5,
                        _0: terminatingTokens
                      },
                      tl: stack
                    };
                    _state = /* ExpectingCloseBracketOrExpression */1;
                    _code = tail;
                    _buffer = "";
                    continue ;
                  }
                  exit$2 = 4;
                  if (exit$2 === 4) {
                    if (!isTerminatingCharacter(terminatingTokens, head) && isAlphabetical(head)) {
                      _stack = {
                        hd: {
                          TAG: /* ExpectingExpressionEndOrOperator */5,
                          _0: terminatingTokens
                        },
                        tl: stack
                      };
                      _state = {
                        TAG: /* WaitingTerminateWord */3,
                        _0: terminatingTokens
                      };
                      _code = tail;
                      _buffer = head;
                      continue ;
                    }
                    if (!isTerminatingCharacter(terminatingTokens, head) && isNumeric(head)) {
                      _stack = {
                        hd: {
                          TAG: /* ExpectingExpressionEndOrOperator */5,
                          _0: terminatingTokens
                        },
                        tl: stack
                      };
                      _state = {
                        TAG: /* WaitingTerminateNumber */4,
                        _0: terminatingTokens
                      };
                      _code = tail;
                      _buffer = head;
                      continue ;
                    }
                    if (head === "\"" && !isTerminatingCharacter(terminatingTokens, "\"")) {
                      _stack = {
                        hd: {
                          TAG: /* ExpectingExpressionEndOrOperator */5,
                          _0: terminatingTokens
                        },
                        tl: stack
                      };
                      _state = /* WaitingTerminateString */0;
                      _code = tail;
                      _buffer = "";
                      continue ;
                    }
                    
                  }
                  
                }
                break;
            case /* ExpectingWord */1 :
                if (buffer === "" && isAlphabetical(head)) {
                  _state = {
                    TAG: /* WaitingTerminateWord */3,
                    _0: state._0
                  };
                  _code = tail;
                  _buffer = head;
                  continue ;
                }
                break;
            case /* ProcessingWordOrExpression */2 :
                if (buffer === "") {
                  if (head === "(") {
                    console.log("OPENBRACKET");
                    _parsedTokens = {
                      hd: /* OpenBracket */0,
                      tl: parsedTokens
                    };
                    _state = /* ExpectingCloseBracketOrExpression */1;
                    _code = tail;
                    _buffer = "";
                    continue ;
                  }
                  exit$1 = 3;
                } else {
                  exit$1 = 3;
                }
                break;
            case /* WaitingTerminateWord */3 :
                if (!isTerminatingCharacter(state._0, head)) {
                  if (typeof state !== "number" && state.TAG === /* WaitingTerminateWord */3) {
                    var terminatingTokens$1 = state._0;
                    if (isAlphanumeric(head)) {
                      return innerParseExpression(buffer + head, tail, {
                                  TAG: /* WaitingTerminateWord */3,
                                  _0: terminatingTokens$1
                                }, stack, parsedTokens);
                    }
                    if (head === " ") {
                      console.log("WORD(" + buffer + ")");
                      return innerParseExpression("", tail, Belt_List.headExn(stack), Belt_List.tailExn(stack), {
                                  hd: {
                                    TAG: /* Word */1,
                                    _0: buffer
                                  },
                                  tl: parsedTokens
                                });
                    }
                    if (isOperator(head)) {
                      console.log("WORD(" + buffer + ")");
                      console.log("OPERATOR(" + head + ")");
                      return innerParseExpression("", tail, {
                                  TAG: /* ProcessingWordOrExpression */2,
                                  _0: terminatingTokens$1
                                }, stack, {
                                  hd: {
                                    TAG: /* Operator */0,
                                    _0: head
                                  },
                                  tl: {
                                    hd: {
                                      TAG: /* Word */1,
                                      _0: buffer
                                    },
                                    tl: parsedTokens
                                  }
                                });
                    }
                    switch (head) {
                      case "(" :
                          console.log("FUNCTION(" + buffer + ")");
                          console.log("OPENBRACKET");
                          return innerParseExpression("", tail, /* ExpectingCloseBracketOrFunctionArguments */2, stack, {
                                      hd: /* OpenBracket */0,
                                      tl: {
                                        hd: {
                                          TAG: /* Function */4,
                                          _0: buffer
                                        },
                                        tl: parsedTokens
                                      }
                                    });
                      case "." :
                          console.log("WORD(" + buffer + ")");
                          console.log("DOT");
                          return innerParseExpression("", tail, {
                                      TAG: /* ExpectingWord */1,
                                      _0: terminatingTokens$1
                                    }, stack, {
                                      hd: /* Dot */2,
                                      tl: {
                                        hd: {
                                          TAG: /* Word */1,
                                          _0: buffer
                                        },
                                        tl: parsedTokens
                                      }
                                    });
                      default:
                        
                    }
                  }
                  console.log("state:", expressionStateToString(state));
                  console.log("Buffer:", buffer);
                  console.log("Head:", head);
                  return ;
                }
                console.log("WORD(" + buffer + ")");
                _parsedTokens = {
                  hd: {
                    TAG: /* Word */1,
                    _0: buffer
                  },
                  tl: parsedTokens
                };
                _stack = Belt_List.tailExn(stack);
                _state = Belt_List.headExn(stack);
                _code = {
                  hd: head,
                  tl: tail
                };
                _buffer = "";
                continue ;
            case /* WaitingTerminateNumber */4 :
                if (!isTerminatingCharacter(state._0, head)) {
                  if (typeof state !== "number" && state.TAG === /* WaitingTerminateNumber */4) {
                    var terminatingTokens$2 = state._0;
                    if (isNumeric(head)) {
                      return innerParseExpression(buffer + head, tail, {
                                  TAG: /* WaitingTerminateNumber */4,
                                  _0: terminatingTokens$2
                                }, stack, parsedTokens);
                    }
                    if (isOperator(head)) {
                      console.log("NUMBER(" + buffer + ")");
                      console.log("OPERATOR(" + head + ")");
                      return innerParseExpression("", tail, {
                                  TAG: /* ProcessingWordOrExpression */2,
                                  _0: terminatingTokens$2
                                }, stack, {
                                  hd: {
                                    TAG: /* Operator */0,
                                    _0: head
                                  },
                                  tl: {
                                    hd: {
                                      TAG: /* Number */3,
                                      _0: Belt_Option.getExn(Belt_Int.fromString(buffer))
                                    },
                                    tl: parsedTokens
                                  }
                                });
                    }
                    switch (head) {
                      case " " :
                          console.log("NUMBER(" + buffer + ")");
                          return innerParseExpression("", tail, Belt_List.headExn(stack), Belt_List.tailExn(stack), {
                                      hd: {
                                        TAG: /* Number */3,
                                        _0: Belt_Option.getExn(Belt_Int.fromString(buffer))
                                      },
                                      tl: parsedTokens
                                    });
                      case ")" :
                          console.log("NUMBER(" + buffer + ")");
                          return innerParseExpression("", {
                                      hd: head,
                                      tl: tail
                                    }, Belt_List.headExn(stack), Belt_List.tailExn(stack), {
                                      hd: {
                                        TAG: /* Number */3,
                                        _0: Belt_Option.getExn(Belt_Int.fromString(buffer))
                                      },
                                      tl: parsedTokens
                                    });
                      default:
                        
                    }
                  }
                  console.log("state:", expressionStateToString(state));
                  console.log("Buffer:", buffer);
                  console.log("Head:", head);
                  return ;
                }
                console.log("NUMBER(" + buffer + ")");
                _parsedTokens = {
                  hd: {
                    TAG: /* Number */3,
                    _0: Belt_Option.getExn(Belt_Int.fromString(buffer))
                  },
                  tl: parsedTokens
                };
                _stack = Belt_List.tailExn(stack);
                _state = Belt_List.headExn(stack);
                _code = {
                  hd: head,
                  tl: tail
                };
                _buffer = "";
                continue ;
            case /* ExpectingExpressionEndOrOperator */5 :
                var terminatingTokens$3 = state._0;
                if (buffer === "") {
                  var exit$3 = 0;
                  if (isTerminatingCharacter(terminatingTokens$3, head)) {
                    var stackHead = Belt_List.head(stack);
                    if (stackHead === undefined) {
                      return {
                              tokens: parsedTokens,
                              remainingCode: tail
                            };
                    }
                    _stack = Belt_Option.getWithDefault(Belt_List.tail(stack), /* [] */0);
                    _state = stackHead;
                    _code = {
                      hd: head,
                      tl: tail
                    };
                    _buffer = "";
                    continue ;
                  }
                  if (head === " " && !isTerminatingCharacter(terminatingTokens$3, " ")) {
                    _state = {
                      TAG: /* ExpectingExpressionEndOrOperator */5,
                      _0: terminatingTokens$3
                    };
                    _code = tail;
                    _buffer = "";
                    continue ;
                  }
                  exit$3 = 4;
                  if (exit$3 === 4 && !isTerminatingCharacter(terminatingTokens$3, head) && isOperator(head)) {
                    console.log("OPERATOR(" + head + ")");
                    _parsedTokens = {
                      hd: {
                        TAG: /* Operator */0,
                        _0: head
                      },
                      tl: parsedTokens
                    };
                    _stack = {
                      hd: state,
                      tl: stack
                    };
                    _state = {
                      TAG: /* ProcessingWordOrExpression */2,
                      _0: terminatingTokens$3
                    };
                    _code = tail;
                    _buffer = "";
                    continue ;
                  }
                  
                }
                break;
            
          }
        }
        if (exit$1 === 3) {
          if (buffer === "") {
            if (head === " ") {
              _code = tail;
              _buffer = "";
              continue ;
            }
            exit = 2;
          } else {
            exit = 2;
          }
        }
        if (exit === 2) {
          if (typeof state === "number") {
            if (buffer === "") {
              if (isNumeric(head)) {
                _stack = {
                  hd: state,
                  tl: stack
                };
                _state = {
                  TAG: /* WaitingTerminateNumber */4,
                  _0: {
                    hd: ")",
                    tl: /* [] */0
                  }
                };
                _code = tail;
                _buffer = head;
                continue ;
              }
              if (isAlphabetical(head)) {
                _stack = {
                  hd: state,
                  tl: stack
                };
                _state = {
                  TAG: /* WaitingTerminateWord */3,
                  _0: {
                    hd: ")",
                    tl: /* [] */0
                  }
                };
                _code = tail;
                _buffer = head;
                continue ;
              }
              if (isOperator(head)) {
                console.log("OPERATOR(" + head + ")");
                _parsedTokens = {
                  hd: {
                    TAG: /* Operator */0,
                    _0: head
                  },
                  tl: parsedTokens
                };
                _stack = {
                  hd: state,
                  tl: stack
                };
                _state = {
                  TAG: /* ProcessingWordOrExpression */2,
                  _0: {
                    hd: ")",
                    tl: /* [] */0
                  }
                };
                _code = tail;
                _buffer = "";
                continue ;
              }
              if (head === ")") {
                console.log("CLOSEBRACKET");
                _parsedTokens = {
                  hd: /* ClosedBracket */1,
                  tl: parsedTokens
                };
                _stack = Belt_List.tailExn(stack);
                _state = Belt_List.headExn(stack);
                _code = tail;
                _buffer = "";
                continue ;
              }
              
            }
            
          } else {
            var terminatingTokens$4 = state._0;
            if (buffer === "") {
              if (isNumeric(head)) {
                _state = {
                  TAG: /* WaitingTerminateNumber */4,
                  _0: terminatingTokens$4
                };
                _code = tail;
                _buffer = head;
                continue ;
              }
              if (isAlphabetical(head)) {
                _state = {
                  TAG: /* WaitingTerminateWord */3,
                  _0: terminatingTokens$4
                };
                _code = tail;
                _buffer = head;
                continue ;
              }
              if (isTerminatingCharacter(terminatingTokens$4, head)) {
                _stack = Belt_List.tailExn(stack);
                _state = Belt_List.headExn(stack);
                _code = {
                  hd: head,
                  tl: tail
                };
                _buffer = "";
                continue ;
              }
              if (head === "\"") {
                _state = /* WaitingTerminateString */0;
                _code = tail;
                _buffer = "";
                continue ;
              }
              
            }
            
          }
        }
        console.log("state:", expressionStateToString(state));
        console.log("Buffer:", buffer);
        console.log("Head:", head);
        return ;
      }
      if (typeof state !== "number") {
        switch (state.TAG | 0) {
          case /* ProcessingWordOrExpression */2 :
              if (buffer === "") {
                _stack = Belt_List.tailExn(stack);
                _state = Belt_List.headExn(stack);
                _code = /* [] */0;
                _buffer = "";
                continue ;
              }
              break;
          case /* WaitingTerminateWord */3 :
              console.log("WORD(" + buffer + ")");
              _parsedTokens = {
                hd: {
                  TAG: /* Word */1,
                  _0: buffer
                },
                tl: parsedTokens
              };
              _stack = Belt_List.tailExn(stack);
              _state = Belt_List.headExn(stack);
              _code = /* [] */0;
              _buffer = "";
              continue ;
          case /* WaitingTerminateNumber */4 :
              console.log("NUMBER(" + buffer + ")");
              _parsedTokens = {
                hd: {
                  TAG: /* Number */3,
                  _0: Belt_Option.getExn(Belt_Int.fromString(buffer))
                },
                tl: parsedTokens
              };
              _stack = Belt_List.tailExn(stack);
              _state = Belt_List.headExn(stack);
              _code = /* [] */0;
              _buffer = "";
              continue ;
          case /* ExpectingExpressionEndOrOperator */5 :
              if (buffer === "") {
                console.log("REALEND");
                return {
                        tokens: parsedTokens,
                        remainingCode: /* [] */0
                      };
              }
              break;
          default:
            
        }
      }
      console.log("state:", expressionStateToString(state));
      console.log("Buffer:", buffer);
      console.log("list empty");
      return ;
    };
  };
  return innerParseExpression(buffer, code, {
              TAG: /* ExpressionStart */0,
              _0: finalTerminatingTokens
            }, /* [] */0, /* [] */0);
}

var parsed = Belt_List.reverse(parseExpression("", Belt_List.fromArray(Array.from("\"hellothere\" + Method.name(5, Person.getAge()) + \"hello\" + (a.name.b + (5 / 2)+10) + b.getAge(hello, 123, h12) + ; 1 + 1", (function (x) {
                    return x;
                  }))), {
          hd: ";",
          tl: /* [] */0
        }).tokens);

console.log(Belt_Array.joinWithU(Belt_Array.mapU(Belt_List.toArray(parsed), (function (token) {
                if (typeof token === "number") {
                  switch (token) {
                    case /* OpenBracket */0 :
                        return "OpenBracket";
                    case /* ClosedBracket */1 :
                        return "ClosedBracket";
                    case /* Dot */2 :
                        return "Dot";
                    case /* Comma */3 :
                        return "Comma";
                    
                  }
                } else {
                  switch (token.TAG | 0) {
                    case /* Operator */0 :
                        return "Operator(" + token._0 + ")";
                    case /* Word */1 :
                        return "Word(" + token._0 + ")";
                    case /* String */2 :
                        return "String(" + token._0 + ")";
                    case /* Number */3 :
                        return "Number(" + String(token._0) + ")";
                    case /* Function */4 :
                        return "Function(" + token._0 + ")";
                    
                  }
                }
              })), ",", (function (a) {
            return a;
          })));

console.log(Belt_List.reduceU(parsed, "", (function (acc, token) {
            var tmp;
            if (typeof token === "number") {
              switch (token) {
                case /* OpenBracket */0 :
                    tmp = "(";
                    break;
                case /* ClosedBracket */1 :
                    tmp = ")";
                    break;
                case /* Dot */2 :
                    tmp = ".";
                    break;
                case /* Comma */3 :
                    tmp = ", ";
                    break;
                
              }
            } else {
              switch (token.TAG | 0) {
                case /* Operator */0 :
                    tmp = " " + token._0 + " ";
                    break;
                case /* String */2 :
                    tmp = "\"" + token._0 + "\"";
                    break;
                case /* Number */3 :
                    tmp = String(token._0);
                    break;
                case /* Word */1 :
                case /* Function */4 :
                    tmp = token._0;
                    break;
                
              }
            }
            return acc + tmp;
          })));

var code = "\nif (WorldGen.destroyObject)\n        {\n            return;\n        }\n        let y: int = j - (world.getTile({ x: i, y: j }).frameY / 18) as int;\n        let fX: int = world.getTile({ x: i, y: j }).frameX as int;\n        let fX2: int = 0;\n        while (fX >= 5000)\n        {\n            fX -= 5000;\n            fX2++;\n        }\n        if (fX2 != 0)\n        {\n            fX = (fX2 - 1) * 18;\n        }\n         for (int f2 = 0; f2 < h; f2++)\n            {\n                if (world.getTile({ x: x, y: y + f2 }).type == (ushort)type)\n                {\n                    WorldGen.KillTile(x, y + f2, false, false, false);\n                }\n            }\n";

exports.code = code;
exports.isNumeric = isNumeric;
exports.isAlphabetical = isAlphabetical;
exports.isAlphanumeric = isAlphanumeric;
exports.parseLetType = parseLetType;
exports.parseLetEquals = parseLetEquals;
exports.parseBlock = parseBlock;
exports.parseIf = parseIf;
exports.parseLet = parseLet;
exports.parseCode = parseCode;
exports.strToTokenList = strToTokenList;
exports.expressionStateToString = expressionStateToString;
exports.isTerminatingCharacter = isTerminatingCharacter;
exports.isOperator = isOperator;
exports.parseExpression = parseExpression;
exports.parsed = parsed;
/* parsed Not a pure module */
