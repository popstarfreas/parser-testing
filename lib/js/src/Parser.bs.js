// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Int = require("bs-platform/lib/js/belt_Int.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");

function isNumeric(character) {
  switch (character) {
    case "0" :
    case "1" :
    case "2" :
    case "3" :
    case "4" :
    case "5" :
    case "6" :
    case "7" :
    case "8" :
    case "9" :
        return true;
    default:
      return false;
  }
}

function isAlphabetical(character) {
  switch (character) {
    case "A" :
    case "B" :
    case "C" :
    case "D" :
    case "E" :
    case "F" :
    case "G" :
    case "H" :
    case "I" :
    case "J" :
    case "K" :
    case "L" :
    case "M" :
    case "N" :
    case "O" :
    case "P" :
    case "Q" :
    case "R" :
    case "S" :
    case "T" :
    case "U" :
    case "V" :
    case "W" :
    case "X" :
    case "Y" :
    case "Z" :
    case "a" :
    case "b" :
    case "c" :
    case "d" :
    case "e" :
    case "f" :
    case "g" :
    case "h" :
    case "i" :
    case "j" :
    case "k" :
    case "l" :
    case "m" :
    case "n" :
    case "o" :
    case "p" :
    case "q" :
    case "r" :
    case "s" :
    case "t" :
    case "u" :
    case "v" :
    case "w" :
    case "x" :
    case "y" :
    case "z" :
        return true;
    default:
      return false;
  }
}

function isAlphanumeric(character) {
  if (isNumeric(character)) {
    return true;
  } else {
    return isAlphabetical(character);
  }
}

function parseLetType(_buffer, _code) {
  while(true) {
    var code = _code;
    var buffer = _buffer;
    if (!code) {
      return ;
    }
    var tail = code.tl;
    var head = code.hd;
    if (isAlphanumeric(head)) {
      _code = tail;
      _buffer = buffer + head;
      continue ;
    }
    if (buffer === "" && head === " ") {
      _code = tail;
      _buffer = "";
      continue ;
    }
    if (head === " ") {
      return [
              buffer,
              tail
            ];
    }
    console.log("Unexpected", head, "when parsing let type");
    return ;
  };
}

function parseLetEquals(_buffer, _code) {
  while(true) {
    var code = _code;
    var buffer = _buffer;
    if (!code) {
      return ;
    }
    var head = code.hd;
    if (buffer === "") {
      if (head === " ") {
        _code = code.tl;
        _buffer = "";
        continue ;
      }
      console.log("Unexpected", head, "when parsing let equals");
      return ;
    }
    console.log("Unexpected", head, "when parsing let equals");
    return ;
  };
}

function parseBlock(_buffer, _code) {
  while(true) {
    var code = _code;
    var buffer = _buffer;
    if (!code) {
      return ;
    }
    var tail = code.tl;
    var head = code.hd;
    var exit = 0;
    var word;
    var exit$1 = 0;
    var exit$2 = 0;
    if (isAlphanumeric(head)) {
      _code = tail;
      _buffer = buffer + head;
      continue ;
    }
    switch (buffer) {
      case "" :
          switch (head) {
            case "\n" :
            case " " :
                _code = tail;
                _buffer = "";
                continue ;
            case "{" :
                console.log("OPEN BLOCK");
                _code = tail;
                _buffer = "";
                continue ;
            case "}" :
                console.log("CLOSE BLOCK");
                _code = tail;
                _buffer = "";
                continue ;
            default:
              exit = 1;
          }
          break;
      case "if" :
          if (head === "(") {
            word = buffer;
            exit = 2;
          } else {
            exit$2 = 4;
          }
          break;
      case "return" :
          if (head === ";") {
            word = buffer;
            exit = 2;
          } else {
            exit$2 = 4;
          }
          break;
      default:
        exit$1 = 3;
    }
    if (exit$2 === 4) {
      if (head === "\n") {
        word = buffer;
        exit = 2;
      } else {
        exit$1 = 3;
      }
    }
    if (exit$1 === 3) {
      var exit$3 = 0;
      switch (buffer) {
        case "if" :
        case "let" :
        case "return" :
            exit$3 = 4;
            break;
        default:
          exit = 1;
      }
      if (exit$3 === 4) {
        if (head === " ") {
          word = buffer;
          exit = 2;
        } else {
          exit = 1;
        }
      }
      
    }
    switch (exit) {
      case 1 :
          console.log("Unexpected", head, "when parsing word", buffer);
          return ;
      case 2 :
          switch (word) {
            case "if" :
                console.log("IF");
                return parseIf("", code);
            case "let" :
                console.log("LET");
                return parseLet("", tail);
            case "return" :
                console.log("RETURN");
                _code = tail;
                _buffer = "";
                continue ;
            default:
              console.log("Word(" + word + ")");
              _code = tail;
              _buffer = "";
              continue ;
          }
      
    }
  };
}

function parseIf(_buffer, _code) {
  while(true) {
    var code = _code;
    var buffer = _buffer;
    if (!code) {
      return ;
    }
    var tail = code.tl;
    var head = code.hd;
    if (buffer === "") {
      switch (head) {
        case " " :
        case "(" :
            _code = tail;
            _buffer = "";
            continue ;
        default:
          
      }
    }
    if (isAlphanumeric(head)) {
      _code = tail;
      _buffer = buffer + head;
      continue ;
    }
    switch (head) {
      case " " :
          console.log("Word(" + buffer + ")");
          return ;
      case ")" :
          console.log("Word(" + buffer + ")\nENDIF");
          return parseBlock("", tail);
      case "." :
          console.log("NamespaceOrObject(" + buffer + ")\nDOT");
          _code = tail;
          _buffer = "";
          continue ;
      default:
        console.log("Non alphanumeric in IF.", head);
        return ;
    }
  };
}

function parseLet(_buffer, _code) {
  while(true) {
    var code = _code;
    var buffer = _buffer;
    if (!code) {
      return ;
    }
    var tail = code.tl;
    var head = code.hd;
    if (isAlphanumeric(head)) {
      _code = tail;
      _buffer = buffer + head;
      continue ;
    }
    switch (head) {
      case " " :
          console.log("Word(" + buffer + ")");
          return ;
      case ")" :
          console.log("Word(" + buffer + ")\nENDIF");
          return parseBlock("", tail);
      case "." :
          console.log("NamespaceOrObject(" + buffer + ")\nDOT");
          _code = tail;
          _buffer = "";
          continue ;
      case ":" :
          console.log("Word(" + buffer + ")");
          var match = parseLetType("", tail);
          if (match !== undefined) {
            console.log("TYPE(" + match[0] + ")");
          } else {
            console.log("Could not parse let type");
          }
          return ;
      default:
        console.log("Unexpected", head, "when parsing let word", buffer);
        return ;
    }
  };
}

function parseCode(codeStr) {
  var code = Belt_List.fromArray(Array.from(codeStr, (function (x) {
              return x;
            })));
  return parseBlock("", code);
}

function strToTokenList(codeStr) {
  return Belt_List.fromArray(Array.from(codeStr, (function (x) {
                    return x;
                  })));
}

function expressionStateToString(state) {
  if (typeof state !== "number") {
    if (state.TAG === /* ExpressionStart */0) {
      return "ExpectingWord";
    } else {
      return "ExpectingExpressionEndOrOperator";
    }
  }
  switch (state) {
    case /* ExpectingWord */0 :
        return "ExpectingWord";
    case /* ProcessingWordOrExpression */1 :
        return "ProcessingWordOrExpression";
    case /* WaitingTerminateWord */2 :
        return "WaitingTerminateWord";
    case /* WaitingTerminateString */3 :
        return "WaitingTerminateString";
    case /* WaitingTerminateArgument */4 :
        return "WaitingTerminateArgument";
    case /* WaitingTerminateNumberArgument */5 :
        return "WaitingTerminateNumberArgument";
    case /* WaitingTerminateNumber */6 :
        return "WaitingTerminateNumber";
    case /* ExpectingCloseBracketOrExpression */7 :
        return "ExpectingCloseBracketOrExpression";
    case /* ExpectingCloseBracketOrFunctionArguments */8 :
        return "ExpectingCloseBracketOrFunctionArguments";
    case /* WaitingOperation */9 :
        return "WaitingOperation";
    
  }
}

function isOperator(character) {
  switch (character) {
    case "*" :
    case "+" :
    case "-" :
    case "/" :
        return true;
    default:
      return false;
  }
}

function parseExpression(buffer, code, terminatingToken) {
  var innerParseExpression = function (_buffer, _code, _state, _stack, _parsedTokens) {
    while(true) {
      var parsedTokens = _parsedTokens;
      var stack = _stack;
      var state = _state;
      var code = _code;
      var buffer = _buffer;
      if (code) {
        var tail = code.tl;
        var head = code.hd;
        var exit = 0;
        var exit$1 = 0;
        if (typeof state === "number") {
          switch (state) {
            case /* ExpectingWord */0 :
                if (buffer === "" && isAlphabetical(head)) {
                  _state = /* WaitingTerminateWord */2;
                  _code = tail;
                  _buffer = head;
                  continue ;
                }
                break;
            case /* ProcessingWordOrExpression */1 :
                if (buffer === "") {
                  if (head === "(") {
                    console.log("OPENBRACKET");
                    _parsedTokens = {
                      hd: /* OpenBracket */0,
                      tl: parsedTokens
                    };
                    _state = /* ExpectingCloseBracketOrExpression */7;
                    _code = tail;
                    _buffer = "";
                    continue ;
                  }
                  exit$1 = 3;
                } else {
                  exit$1 = 3;
                }
                break;
            case /* WaitingTerminateWord */2 :
                if (head !== terminatingToken) {
                  if (state === 2) {
                    if (isAlphanumeric(head)) {
                      return innerParseExpression(buffer + head, tail, /* WaitingTerminateWord */2, stack, parsedTokens);
                    }
                    if (head === " ") {
                      console.log("WORD(" + buffer + ")");
                      return innerParseExpression("", tail, Belt_List.headExn(stack), Belt_List.tailExn(stack), {
                                  hd: {
                                    TAG: /* Word */1,
                                    _0: buffer
                                  },
                                  tl: parsedTokens
                                });
                    }
                    if (isOperator(head)) {
                      console.log("WORD(" + buffer + ")");
                      console.log("OPERATOR(" + head + ")");
                      return innerParseExpression("", tail, /* ProcessingWordOrExpression */1, stack, {
                                  hd: {
                                    TAG: /* Operator */0,
                                    _0: head
                                  },
                                  tl: {
                                    hd: {
                                      TAG: /* Word */1,
                                      _0: buffer
                                    },
                                    tl: parsedTokens
                                  }
                                });
                    }
                    switch (head) {
                      case "(" :
                          console.log("FUNCTION(" + buffer + ")");
                          console.log("OPENBRACKET");
                          return innerParseExpression("", tail, /* ExpectingCloseBracketOrFunctionArguments */8, stack, {
                                      hd: /* OpenBracket */0,
                                      tl: {
                                        hd: {
                                          TAG: /* Function */4,
                                          _0: buffer
                                        },
                                        tl: parsedTokens
                                      }
                                    });
                      case "." :
                          console.log("WORD(" + buffer + ")");
                          console.log("DOT");
                          return innerParseExpression("", tail, /* ExpectingWord */0, stack, {
                                      hd: /* Dot */2,
                                      tl: {
                                        hd: {
                                          TAG: /* Word */1,
                                          _0: buffer
                                        },
                                        tl: parsedTokens
                                      }
                                    });
                      default:
                        
                    }
                  }
                  console.log("state:", expressionStateToString(state));
                  console.log("Buffer:", buffer);
                  console.log("Head:", head);
                  return ;
                }
                console.log("WORD(" + buffer + ")");
                _parsedTokens = {
                  hd: {
                    TAG: /* Word */1,
                    _0: buffer
                  },
                  tl: parsedTokens
                };
                _stack = Belt_List.tailExn(stack);
                _state = Belt_List.headExn(stack);
                _code = /* [] */0;
                _buffer = "";
                continue ;
            case /* WaitingTerminateString */3 :
                if (state === 3) {
                  if (head !== "\"") {
                    return innerParseExpression(buffer + head, tail, /* WaitingTerminateString */3, stack, parsedTokens);
                  }
                  console.log("STRING(" + buffer + ")");
                  return innerParseExpression("", tail, Belt_List.headExn(stack), Belt_List.tailExn(stack), {
                              hd: {
                                TAG: /* String */2,
                                _0: buffer
                              },
                              tl: parsedTokens
                            });
                }
                console.log("state:", expressionStateToString(state));
                console.log("Buffer:", buffer);
                console.log("Head:", head);
                return ;
            case /* WaitingTerminateNumber */6 :
                if (head !== terminatingToken) {
                  if (state === 6) {
                    if (isNumeric(head)) {
                      return innerParseExpression(buffer + head, tail, /* WaitingTerminateNumber */6, stack, parsedTokens);
                    }
                    if (isOperator(head)) {
                      console.log("NUMBER(" + buffer + ")");
                      console.log("OPERATOR(" + head + ")");
                      return innerParseExpression("", tail, /* ProcessingWordOrExpression */1, stack, {
                                  hd: {
                                    TAG: /* Operator */0,
                                    _0: head
                                  },
                                  tl: {
                                    hd: {
                                      TAG: /* Number */3,
                                      _0: Belt_Option.getExn(Belt_Int.fromString(buffer))
                                    },
                                    tl: parsedTokens
                                  }
                                });
                    }
                    switch (head) {
                      case " " :
                          console.log("NUMBER(" + buffer + ")");
                          return innerParseExpression("", tail, Belt_List.headExn(stack), Belt_List.tailExn(stack), {
                                      hd: {
                                        TAG: /* Number */3,
                                        _0: Belt_Option.getExn(Belt_Int.fromString(buffer))
                                      },
                                      tl: parsedTokens
                                    });
                      case ")" :
                          console.log("NUMBER(" + buffer + ")");
                          return innerParseExpression("", {
                                      hd: head,
                                      tl: tail
                                    }, Belt_List.headExn(stack), Belt_List.tailExn(stack), {
                                      hd: {
                                        TAG: /* Number */3,
                                        _0: Belt_Option.getExn(Belt_Int.fromString(buffer))
                                      },
                                      tl: parsedTokens
                                    });
                      default:
                        
                    }
                  }
                  console.log("state:", expressionStateToString(state));
                  console.log("Buffer:", buffer);
                  console.log("Head:", head);
                  return ;
                }
                console.log("NUMBER(" + buffer + ")");
                _parsedTokens = {
                  hd: {
                    TAG: /* Number */3,
                    _0: Belt_Option.getExn(Belt_Int.fromString(buffer))
                  },
                  tl: parsedTokens
                };
                _stack = Belt_List.tailExn(stack);
                _state = Belt_List.headExn(stack);
                _code = /* [] */0;
                _buffer = "";
                continue ;
            case /* ExpectingCloseBracketOrExpression */7 :
                exit$1 = 3;
                break;
            case /* WaitingOperation */9 :
                break;
            default:
              if (typeof state === "number") {
                switch (state) {
                  case /* WaitingTerminateArgument */4 :
                      if (head === ")") {
                        console.log("LASTARGUMENT(" + buffer + ")");
                        return innerParseExpression("", {
                                    hd: head,
                                    tl: tail
                                  }, Belt_List.headExn(stack), Belt_List.tailExn(stack), {
                                    hd: {
                                      TAG: /* LastArgument */6,
                                      _0: buffer
                                    },
                                    tl: parsedTokens
                                  });
                      }
                      if (isAlphanumeric(head)) {
                        return innerParseExpression(buffer + head, tail, /* WaitingTerminateArgument */4, stack, parsedTokens);
                      }
                      if (head === ",") {
                        console.log("ARGUMENT(" + buffer + ")");
                        return innerParseExpression("", tail, Belt_List.headExn(stack), Belt_List.tailExn(stack), {
                                    hd: {
                                      TAG: /* Argument */5,
                                      _0: buffer
                                    },
                                    tl: parsedTokens
                                  });
                      }
                      break;
                  case /* WaitingTerminateNumberArgument */5 :
                      if (head === ")") {
                        console.log("LASTNUMBERARGUMENT(" + buffer + ")");
                        return innerParseExpression("", {
                                    hd: head,
                                    tl: tail
                                  }, Belt_List.headExn(stack), Belt_List.tailExn(stack), {
                                    hd: {
                                      TAG: /* LastNumberArgument */8,
                                      _0: Belt_Option.getExn(Belt_Int.fromString(buffer))
                                    },
                                    tl: parsedTokens
                                  });
                      }
                      if (isNumeric(head)) {
                        return innerParseExpression(buffer + head, tail, /* WaitingTerminateNumberArgument */5, stack, parsedTokens);
                      }
                      if (head === ",") {
                        console.log("NUMBERARGUMENT(" + buffer + ")");
                        return innerParseExpression("", tail, Belt_List.headExn(stack), Belt_List.tailExn(stack), {
                                    hd: {
                                      TAG: /* NumberArgument */7,
                                      _0: Belt_Option.getExn(Belt_Int.fromString(buffer))
                                    },
                                    tl: parsedTokens
                                  });
                      }
                      break;
                  case /* ExpectingCloseBracketOrFunctionArguments */8 :
                      if (buffer === "") {
                        switch (head) {
                          case " " :
                              return innerParseExpression("", tail, /* ExpectingCloseBracketOrFunctionArguments */8, stack, parsedTokens);
                          case ")" :
                              console.log("CLOSEBRACKET");
                              return innerParseExpression("", tail, Belt_List.headExn(stack), Belt_List.tailExn(stack), {
                                          hd: /* ClosedBracket */1,
                                          tl: parsedTokens
                                        });
                          default:
                            if (isAlphabetical(head)) {
                              return innerParseExpression(head, tail, /* WaitingTerminateArgument */4, {
                                          hd: state,
                                          tl: stack
                                        }, parsedTokens);
                            }
                            if (isNumeric(head)) {
                              return innerParseExpression(head, tail, /* WaitingTerminateNumberArgument */5, {
                                          hd: state,
                                          tl: stack
                                        }, parsedTokens);
                            }
                            
                        }
                      }
                      break;
                  case /* ExpectingWord */0 :
                  case /* ProcessingWordOrExpression */1 :
                  case /* WaitingTerminateWord */2 :
                  case /* WaitingTerminateString */3 :
                  case /* WaitingTerminateNumber */6 :
                  case /* ExpectingCloseBracketOrExpression */7 :
                  case /* WaitingOperation */9 :
                      break;
                  
                }
              }
              console.log("state:", expressionStateToString(state));
              console.log("Buffer:", buffer);
              console.log("Head:", head);
              return ;
          }
        } else if (state.TAG === /* ExpressionStart */0) {
          var terminatingToken$1 = state._0;
          if (buffer === "") {
            var exit$2 = 0;
            if (head === "(") {
              if (terminatingToken$1 !== "(") {
                console.log("OPENBRACKET");
                _parsedTokens = {
                  hd: /* OpenBracket */0,
                  tl: parsedTokens
                };
                _stack = {
                  hd: {
                    TAG: /* ExpectingExpressionEndOrOperator */1,
                    _0: terminatingToken$1
                  },
                  tl: stack
                };
                _state = /* ExpectingCloseBracketOrExpression */7;
                _code = tail;
                _buffer = "";
                continue ;
              }
              exit$2 = 4;
            } else {
              exit$2 = 4;
            }
            if (exit$2 === 4) {
              if (terminatingToken$1 !== head && isAlphabetical(head)) {
                _stack = {
                  hd: {
                    TAG: /* ExpectingExpressionEndOrOperator */1,
                    _0: terminatingToken$1
                  },
                  tl: stack
                };
                _state = /* WaitingTerminateWord */2;
                _code = tail;
                _buffer = head;
                continue ;
              }
              if (head === "\"" && terminatingToken$1 !== "\"") {
                _stack = {
                  hd: {
                    TAG: /* ExpectingExpressionEndOrOperator */1,
                    _0: terminatingToken$1
                  },
                  tl: stack
                };
                _state = /* WaitingTerminateString */3;
                _code = tail;
                _buffer = "";
                continue ;
              }
              
            }
            
          }
          
        } else {
          var terminatingToken$2 = state._0;
          if (buffer === "") {
            var exit$3 = 0;
            if (head === terminatingToken$2) {
              console.log("END");
              return {
                      tokens: parsedTokens,
                      remainingCode: tail
                    };
            }
            if (head === " ") {
              if (terminatingToken$2 !== " ") {
                _state = {
                  TAG: /* ExpectingExpressionEndOrOperator */1,
                  _0: terminatingToken$2
                };
                _code = tail;
                _buffer = "";
                continue ;
              }
              exit$3 = 4;
            } else {
              exit$3 = 4;
            }
            if (exit$3 === 4 && terminatingToken$2 !== head && isOperator(head)) {
              console.log("OPERATOR(" + head + ")");
              _parsedTokens = {
                hd: {
                  TAG: /* Operator */0,
                  _0: head
                },
                tl: parsedTokens
              };
              _stack = {
                hd: state,
                tl: stack
              };
              _state = /* ProcessingWordOrExpression */1;
              _code = tail;
              _buffer = "";
              continue ;
            }
            
          }
          
        }
        if (exit$1 === 3) {
          if (buffer === "") {
            if (head === " ") {
              _code = tail;
              _buffer = "";
              continue ;
            }
            exit = 2;
          } else {
            exit = 2;
          }
        }
        if (exit === 2 && typeof state === "number") {
          if (state === /* ProcessingWordOrExpression */1) {
            if (buffer === "") {
              if (isNumeric(head)) {
                _state = /* WaitingTerminateNumber */6;
                _code = tail;
                _buffer = head;
                continue ;
              }
              if (isAlphabetical(head)) {
                _state = /* WaitingTerminateWord */2;
                _code = tail;
                _buffer = head;
                continue ;
              }
              if (head === terminatingToken) {
                _stack = Belt_List.tailExn(stack);
                _state = Belt_List.headExn(stack);
                _code = /* [] */0;
                _buffer = "";
                continue ;
              }
              if (head === "\"") {
                _state = /* WaitingTerminateString */3;
                _code = tail;
                _buffer = "";
                continue ;
              }
              
            }
            
          } else if (buffer === "") {
            if (isNumeric(head)) {
              _stack = {
                hd: state,
                tl: stack
              };
              _state = /* WaitingTerminateNumber */6;
              _code = tail;
              _buffer = head;
              continue ;
            }
            if (isAlphabetical(head)) {
              _stack = {
                hd: state,
                tl: stack
              };
              _state = /* WaitingTerminateWord */2;
              _code = tail;
              _buffer = head;
              continue ;
            }
            if (isOperator(head)) {
              console.log("OPERATOR(" + head + ")");
              _parsedTokens = {
                hd: {
                  TAG: /* Operator */0,
                  _0: head
                },
                tl: parsedTokens
              };
              _stack = {
                hd: state,
                tl: stack
              };
              _state = /* ProcessingWordOrExpression */1;
              _code = tail;
              _buffer = "";
              continue ;
            }
            if (head === ")") {
              console.log("CLOSEBRACKET");
              _parsedTokens = {
                hd: /* ClosedBracket */1,
                tl: parsedTokens
              };
              _stack = Belt_List.tailExn(stack);
              _state = Belt_List.headExn(stack);
              _code = tail;
              _buffer = "";
              continue ;
            }
            
          }
          
        }
        console.log("state:", expressionStateToString(state));
        console.log("Buffer:", buffer);
        console.log("Head:", head);
        return ;
      }
      if (typeof state === "number") {
        switch (state) {
          case /* ProcessingWordOrExpression */1 :
              if (buffer === "") {
                _stack = Belt_List.tailExn(stack);
                _state = Belt_List.headExn(stack);
                _code = /* [] */0;
                _buffer = "";
                continue ;
              }
              break;
          case /* WaitingTerminateWord */2 :
              console.log("WORD(" + buffer + ")");
              _parsedTokens = {
                hd: {
                  TAG: /* Word */1,
                  _0: buffer
                },
                tl: parsedTokens
              };
              _stack = Belt_List.tailExn(stack);
              _state = Belt_List.headExn(stack);
              _code = /* [] */0;
              _buffer = "";
              continue ;
          case /* WaitingTerminateNumber */6 :
              console.log("NUMBER(" + buffer + ")");
              _parsedTokens = {
                hd: {
                  TAG: /* Number */3,
                  _0: Belt_Option.getExn(Belt_Int.fromString(buffer))
                },
                tl: parsedTokens
              };
              _stack = Belt_List.tailExn(stack);
              _state = Belt_List.headExn(stack);
              _code = /* [] */0;
              _buffer = "";
              continue ;
          default:
            
        }
      } else if (state.TAG === /* ExpectingExpressionEndOrOperator */1 && buffer === "") {
        console.log("END");
        return {
                tokens: parsedTokens,
                remainingCode: /* [] */0
              };
      }
      console.log("state:", expressionStateToString(state));
      console.log("Buffer:", buffer);
      console.log("list empty");
      return ;
    };
  };
  return innerParseExpression(buffer, code, {
              TAG: /* ExpressionStart */0,
              _0: terminatingToken
            }, /* [] */0, /* [] */0);
}

var parsed = Belt_List.reverse(parseExpression("", Belt_List.fromArray(Array.from("\"hellothere\" + Method.name(5) + \"hello\" + (a.name.b + (5 / 2)+10) + b.getAge(hello, 123, h12),", (function (x) {
                    return x;
                  }))), ",").tokens);

console.log(Belt_List.reduceU(parsed, "", (function (acc, token) {
            var tmp;
            if (typeof token === "number") {
              switch (token) {
                case /* OpenBracket */0 :
                    tmp = "(";
                    break;
                case /* ClosedBracket */1 :
                    tmp = ")";
                    break;
                case /* Dot */2 :
                    tmp = ".";
                    break;
                
              }
            } else {
              switch (token.TAG | 0) {
                case /* Operator */0 :
                    tmp = " " + token._0 + " ";
                    break;
                case /* String */2 :
                    tmp = "\"" + token._0 + "\"";
                    break;
                case /* Argument */5 :
                    tmp = token._0 + ", ";
                    break;
                case /* NumberArgument */7 :
                    tmp = String(token._0) + ", ";
                    break;
                case /* Number */3 :
                case /* LastNumberArgument */8 :
                    tmp = String(token._0);
                    break;
                default:
                  tmp = token._0;
              }
            }
            return acc + tmp;
          })));

var code = "\nif (WorldGen.destroyObject)\n        {\n            return;\n        }\n        let y: int = j - (world.getTile({ x: i, y: j }).frameY / 18) as int;\n        let fX: int = world.getTile({ x: i, y: j }).frameX as int;\n        let fX2: int = 0;\n        while (fX >= 5000)\n        {\n            fX -= 5000;\n            fX2++;\n        }\n        if (fX2 != 0)\n        {\n            fX = (fX2 - 1) * 18;\n        }\n         for (int f2 = 0; f2 < h; f2++)\n            {\n                if (world.getTile({ x: x, y: y + f2 }).type == (ushort)type)\n                {\n                    WorldGen.KillTile(x, y + f2, false, false, false);\n                }\n            }\n";

exports.code = code;
exports.isNumeric = isNumeric;
exports.isAlphabetical = isAlphabetical;
exports.isAlphanumeric = isAlphanumeric;
exports.parseLetType = parseLetType;
exports.parseLetEquals = parseLetEquals;
exports.parseBlock = parseBlock;
exports.parseIf = parseIf;
exports.parseLet = parseLet;
exports.parseCode = parseCode;
exports.strToTokenList = strToTokenList;
exports.expressionStateToString = expressionStateToString;
exports.isOperator = isOperator;
exports.parseExpression = parseExpression;
exports.parsed = parsed;
/* parsed Not a pure module */
