// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");

var code = "\nif (WorldGen.destroyObject && false || true)\n        {\n            return;\n        }\n        let y: int = j - (world.getTile({ x: i, y: j }).frameY / 18) as int;\n        let fX: int = world.getTile({ x: i, y: j }).frameX as int;\n        let fX2: int = 0;\n        let a: string = \"hello\";";

function isNumeric(character) {
  switch (character) {
    case "0" :
    case "1" :
    case "2" :
    case "3" :
    case "4" :
    case "5" :
    case "6" :
    case "7" :
    case "8" :
    case "9" :
        return true;
    default:
      return false;
  }
}

function isAlphabetical(character) {
  switch (character) {
    case "A" :
    case "B" :
    case "C" :
    case "D" :
    case "E" :
    case "F" :
    case "G" :
    case "H" :
    case "I" :
    case "J" :
    case "K" :
    case "L" :
    case "M" :
    case "N" :
    case "O" :
    case "P" :
    case "Q" :
    case "R" :
    case "S" :
    case "T" :
    case "U" :
    case "V" :
    case "W" :
    case "X" :
    case "Y" :
    case "Z" :
    case "a" :
    case "b" :
    case "c" :
    case "d" :
    case "e" :
    case "f" :
    case "g" :
    case "h" :
    case "i" :
    case "j" :
    case "k" :
    case "l" :
    case "m" :
    case "n" :
    case "o" :
    case "p" :
    case "q" :
    case "r" :
    case "s" :
    case "t" :
    case "u" :
    case "v" :
    case "w" :
    case "x" :
    case "y" :
    case "z" :
        return true;
    default:
      return false;
  }
}

function isAlphanumeric(character) {
  if (isNumeric(character)) {
    return true;
  } else {
    return isAlphabetical(character);
  }
}

function strToTokenList(codeStr) {
  return Belt_List.fromArray(Array.from(codeStr, (function (x) {
                    return x;
                  })));
}

function expressionStateToString(state) {
  if (typeof state === "number") {
    switch (state) {
      case /* Processing */0 :
          return "Processing";
      case /* ProcessingAnd */1 :
          return "ProcessingAnd";
      case /* ProcessingOr */2 :
          return "ProcessingOr";
      
    }
  } else {
    switch (state.TAG | 0) {
      case /* ProcessingWord */0 :
          return "ProcessingWord";
      case /* ProcessingNumber */1 :
          return "ProcessingNumber";
      case /* ProcessingString */2 :
          return "ProcessingString";
      
    }
  }
}

function isTerminatingCharacter(terminationList, character) {
  console.log("isTerminatingCharacter", terminationList, character);
  var result = Belt_List.someU(Belt_Option.mapWithDefaultU(terminationList, /* [] */0, (function (terminationToken) {
              return terminationToken;
            })), (function (terminationToken) {
          return character === terminationToken;
        }));
  console.log(result);
  return result;
}

function isOperator(character) {
  switch (character) {
    case "!" :
    case "*" :
    case "+" :
    case "-" :
    case "/" :
    case "<" :
    case "=" :
    case ">" :
        return true;
    default:
      return false;
  }
}

function parsedTokenToString(token) {
  if (typeof token === "number") {
    switch (token) {
      case /* OpenBracket */0 :
          return "OpenBracket";
      case /* CloseBracket */1 :
          return "CloseBracket";
      case /* Dot */2 :
          return "Dot";
      case /* Comma */3 :
          return "Comma";
      case /* Semicolon */4 :
          return "Semicolon";
      case /* Colon */5 :
          return "Colon";
      case /* OpenBrace */6 :
          return "OpenBrace";
      case /* CloseBrace */7 :
          return "CloseBrace";
      case /* And */8 :
          return "And";
      case /* Or */9 :
          return "Or";
      case /* BitwiseAnd */10 :
          return "BitwiseAnd";
      case /* BitwiseOr */11 :
          return "BitwiseOr";
      
    }
  } else {
    switch (token.TAG | 0) {
      case /* Operator */0 :
          return "Operator(" + token._0 + ")";
      case /* Word */1 :
          return "Word(" + token._0 + ")";
      case /* String */2 :
          return "String(" + token._0 + ")";
      case /* Number */3 :
          return "Number(" + token._0 + ")";
      case /* Function */4 :
          return "Function(" + token._0 + ")";
      
    }
  }
}

function parseExpression(expression) {
  var _state = /* Processing */0;
  var _expression = expression;
  var _parsedTokens = /* [] */0;
  while(true) {
    var parsedTokens = _parsedTokens;
    var expression$1 = _expression;
    var state = _state;
    if (!expression$1) {
      return {
              tokens: parsedTokens,
              remainingCode: /* [] */0
            };
    }
    var otherTokens = expression$1.tl;
    var currentToken = expression$1.hd;
    if (typeof state === "number") {
      switch (state) {
        case /* Processing */0 :
            if (isAlphabetical(currentToken)) {
              _expression = otherTokens;
              _state = {
                TAG: /* ProcessingWord */0,
                _0: currentToken
              };
              continue ;
            }
            if (isNumeric(currentToken)) {
              _expression = otherTokens;
              _state = {
                TAG: /* ProcessingNumber */1,
                _0: currentToken
              };
              continue ;
            }
            if (isOperator(currentToken)) {
              _parsedTokens = {
                hd: {
                  TAG: /* Operator */0,
                  _0: currentToken
                },
                tl: parsedTokens
              };
              _expression = otherTokens;
              _state = /* Processing */0;
              continue ;
            }
            switch (currentToken) {
              case "\n" :
              case " " :
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case "\"" :
                  _expression = otherTokens;
                  _state = {
                    TAG: /* ProcessingString */2,
                    _0: ""
                  };
                  continue ;
              case "&" :
                  _expression = otherTokens;
                  _state = /* ProcessingAnd */1;
                  continue ;
              case "(" :
                  _parsedTokens = {
                    hd: /* OpenBracket */0,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case ")" :
                  _parsedTokens = {
                    hd: /* CloseBracket */1,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case "," :
                  _parsedTokens = {
                    hd: /* Comma */3,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case "." :
                  _parsedTokens = {
                    hd: /* Dot */2,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case ":" :
                  _parsedTokens = {
                    hd: /* Colon */5,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case ";" :
                  _parsedTokens = {
                    hd: /* Semicolon */4,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case "{" :
                  _parsedTokens = {
                    hd: /* OpenBrace */6,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case "|" :
                  _expression = otherTokens;
                  _state = /* ProcessingOr */2;
                  continue ;
              case "}" :
                  _parsedTokens = {
                    hd: /* CloseBrace */7,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              default:
                console.log("Unexpected token: '" + currentToken + "'");
                console.log("in state:", expressionStateToString(state));
                return ;
            }
        case /* ProcessingAnd */1 :
            if (currentToken === "&") {
              _parsedTokens = {
                hd: /* And */8,
                tl: parsedTokens
              };
              _expression = otherTokens;
              _state = /* Processing */0;
              continue ;
            }
            _parsedTokens = {
              hd: /* BitwiseAnd */10,
              tl: parsedTokens
            };
            _expression = otherTokens;
            _state = /* Processing */0;
            continue ;
        case /* ProcessingOr */2 :
            if (currentToken === "|") {
              _parsedTokens = {
                hd: /* Or */9,
                tl: parsedTokens
              };
              _expression = otherTokens;
              _state = /* Processing */0;
              continue ;
            }
            _parsedTokens = {
              hd: /* BitwiseOr */11,
              tl: parsedTokens
            };
            _expression = otherTokens;
            _state = /* Processing */0;
            continue ;
        
      }
    } else {
      switch (state.TAG | 0) {
        case /* ProcessingWord */0 :
            var word = state._0;
            if (isAlphanumeric(currentToken)) {
              _expression = otherTokens;
              _state = {
                TAG: /* ProcessingWord */0,
                _0: word + currentToken
              };
              continue ;
            }
            _parsedTokens = {
              hd: {
                TAG: /* Word */1,
                _0: word
              },
              tl: parsedTokens
            };
            _expression = {
              hd: currentToken,
              tl: otherTokens
            };
            _state = /* Processing */0;
            continue ;
        case /* ProcessingNumber */1 :
            var number = state._0;
            if (isNumeric(currentToken)) {
              _expression = otherTokens;
              _state = {
                TAG: /* ProcessingNumber */1,
                _0: number + currentToken
              };
              continue ;
            }
            _parsedTokens = {
              hd: {
                TAG: /* Number */3,
                _0: number
              },
              tl: parsedTokens
            };
            _expression = {
              hd: currentToken,
              tl: otherTokens
            };
            _state = /* Processing */0;
            continue ;
        case /* ProcessingString */2 :
            var word$1 = state._0;
            if (currentToken === "\"") {
              _parsedTokens = {
                hd: {
                  TAG: /* String */2,
                  _0: word$1
                },
                tl: parsedTokens
              };
              _expression = otherTokens;
              _state = /* Processing */0;
              continue ;
            }
            _expression = otherTokens;
            _state = {
              TAG: /* ProcessingString */2,
              _0: word$1 + currentToken
            };
            continue ;
        
      }
    }
  };
}

var parsed = Belt_List.reverse(parseExpression(Belt_List.fromArray(Array.from(code, (function (x) {
                    return x;
                  })))).tokens);

console.log(Belt_Array.joinWithU(Belt_Array.mapU(Belt_List.toArray(parsed), parsedTokenToString), " ", (function (a) {
            return a;
          })));

console.log(Belt_List.reduceU(parsed, "", (function (acc, token) {
            var tmp;
            if (typeof token === "number") {
              switch (token) {
                case /* OpenBracket */0 :
                    tmp = "(";
                    break;
                case /* CloseBracket */1 :
                    tmp = ")";
                    break;
                case /* Dot */2 :
                    tmp = ".";
                    break;
                case /* Comma */3 :
                    tmp = ", ";
                    break;
                case /* Semicolon */4 :
                    tmp = ";\n";
                    break;
                case /* Colon */5 :
                    tmp = ":";
                    break;
                case /* OpenBrace */6 :
                    tmp = "\n{\n";
                    break;
                case /* CloseBrace */7 :
                    tmp = "\n}\n";
                    break;
                case /* And */8 :
                    tmp = "&&";
                    break;
                case /* Or */9 :
                    tmp = "||";
                    break;
                case /* BitwiseAnd */10 :
                    tmp = "&";
                    break;
                case /* BitwiseOr */11 :
                    tmp = "|";
                    break;
                
              }
            } else {
              switch (token.TAG | 0) {
                case /* Operator */0 :
                    tmp = token._0 + " ";
                    break;
                case /* Word */1 :
                    tmp = token._0 + " ";
                    break;
                case /* String */2 :
                    tmp = "\"" + token._0 + "\"";
                    break;
                case /* Number */3 :
                case /* Function */4 :
                    tmp = token._0;
                    break;
                
              }
            }
            return acc + tmp;
          })));

function parserStateToString(parserState) {
  return "ParsingBlock";
}

function ifParserStateToString(ifParserState) {
  if (ifParserState) {
    return "ParsingIf(" + String(ifParserState._0) + ")";
  } else {
    return "ParseIfNoBracketYet";
  }
}

function parseIfExpression(_state, _expressionTokens, _tokenBuffer) {
  while(true) {
    var tokenBuffer = _tokenBuffer;
    var expressionTokens = _expressionTokens;
    var state = _state;
    if (!expressionTokens) {
      return ;
    }
    var otherTokens = expressionTokens.tl;
    var currentToken = expressionTokens.hd;
    if (state) {
      var nestedBracketCount = state._0;
      if (typeof currentToken === "number") {
        if (currentToken !== 1) {
          if (currentToken !== 0) {
            _expressionTokens = otherTokens;
            continue ;
          }
          _tokenBuffer = {
            hd: currentToken,
            tl: tokenBuffer
          };
          _expressionTokens = otherTokens;
          _state = /* ParsingIf */{
            _0: nestedBracketCount + 1 | 0
          };
          continue ;
        }
        if (nestedBracketCount === 0) {
          return {
                  tokens: Belt_List.reverse(tokenBuffer),
                  restOfTokens: otherTokens
                };
        }
        _expressionTokens = otherTokens;
        _state = /* ParsingIf */{
          _0: nestedBracketCount - 1 | 0
        };
        continue ;
      }
      _expressionTokens = otherTokens;
      continue ;
    }
    if (currentToken === 0) {
      _expressionTokens = otherTokens;
      _state = /* ParsingIf */{
        _0: 0
      };
      continue ;
    }
    console.log(ifParserStateToString(state), "- Unexpected token:", parsedTokenToString(currentToken));
    return ;
  };
}

function statementParserStateToString(statementParserState) {
  if (statementParserState.TAG === /* ParsingStatement */0) {
    return "ParsingStatement(" + String(statementParserState._0) + ")";
  } else {
    return "ParsingStatementOpenBrace(" + String(statementParserState._0) + ")";
  }
}

function parseStatement(_state, _expressionTokens, _tokenBuffer) {
  while(true) {
    var tokenBuffer = _tokenBuffer;
    var expressionTokens = _expressionTokens;
    var state = _state;
    if (!expressionTokens) {
      return ;
    }
    var otherTokens = expressionTokens.tl;
    var currentToken = expressionTokens.hd;
    if (state.TAG === /* ParsingStatement */0) {
      var nestedBracketCount = state._0;
      var exit = 0;
      if (typeof currentToken === "number") {
        switch (currentToken) {
          case /* OpenBracket */0 :
              _tokenBuffer = {
                hd: /* OpenBracket */0,
                tl: tokenBuffer
              };
              _expressionTokens = otherTokens;
              _state = {
                TAG: /* ParsingStatement */0,
                _0: nestedBracketCount + 1 | 0
              };
              continue ;
          case /* CloseBracket */1 :
              _tokenBuffer = {
                hd: /* OpenBracket */0,
                tl: tokenBuffer
              };
              _expressionTokens = otherTokens;
              _state = {
                TAG: /* ParsingStatement */0,
                _0: nestedBracketCount - 1 | 0
              };
              continue ;
          case /* Semicolon */4 :
              if (nestedBracketCount === 0) {
                return {
                        tokens: tokenBuffer,
                        restOfTokens: otherTokens
                      };
              }
              break;
          case /* Dot */2 :
          case /* Colon */5 :
              exit = 2;
              break;
          case /* OpenBrace */6 :
              _tokenBuffer = {
                hd: /* OpenBrace */6,
                tl: tokenBuffer
              };
              _expressionTokens = otherTokens;
              _state = {
                TAG: /* ParsingStatementOpenBrace */1,
                _0: nestedBracketCount
              };
              continue ;
          default:
            
        }
      } else {
        switch (currentToken.TAG | 0) {
          case /* Operator */0 :
          case /* Word */1 :
          case /* String */2 :
          case /* Number */3 :
              exit = 2;
              break;
          default:
            
        }
      }
      if (exit === 2) {
        _tokenBuffer = {
          hd: currentToken,
          tl: tokenBuffer
        };
        _expressionTokens = otherTokens;
        _state = {
          TAG: /* ParsingStatement */0,
          _0: nestedBracketCount
        };
        continue ;
      }
      
    } else {
      var nestedBracketCount$1 = state._0;
      var exit$1 = 0;
      if (typeof currentToken === "number") {
        switch (currentToken) {
          case /* Comma */3 :
          case /* Colon */5 :
              exit$1 = 2;
              break;
          case /* CloseBrace */7 :
              _tokenBuffer = {
                hd: /* CloseBrace */7,
                tl: tokenBuffer
              };
              _expressionTokens = otherTokens;
              _state = {
                TAG: /* ParsingStatement */0,
                _0: nestedBracketCount$1
              };
              continue ;
          default:
            
        }
      } else if (currentToken.TAG === /* Word */1) {
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        _tokenBuffer = {
          hd: currentToken,
          tl: tokenBuffer
        };
        _expressionTokens = otherTokens;
        _state = {
          TAG: /* ParsingStatementOpenBrace */1,
          _0: nestedBracketCount$1
        };
        continue ;
      }
      
    }
    console.log(statementParserStateToString(state), "- Unexpected token:", parsedTokenToString(currentToken));
    return ;
  };
}

function parseExpressionTokens(expressionTokens) {
  var _state = /* ParsingBlock */{
    _0: /* [] */0
  };
  var _expressionTokens = expressionTokens;
  var _stack = /* [] */0;
  var _tokenBuffer = /* [] */0;
  while(true) {
    var tokenBuffer = _tokenBuffer;
    var stack = _stack;
    var expressionTokens$1 = _expressionTokens;
    var state = _state;
    if (expressionTokens$1) {
      var otherTokens = expressionTokens$1.tl;
      var currentToken = expressionTokens$1.hd;
      var blockTokens = state._0;
      if (typeof currentToken === "number") {
        switch (currentToken) {
          case /* OpenBrace */6 :
              _tokenBuffer = /* [] */0;
              _stack = {
                hd: state,
                tl: stack
              };
              _expressionTokens = otherTokens;
              _state = /* ParsingBlock */{
                _0: /* [] */0
              };
              continue ;
          case /* CloseBrace */7 :
              if (Belt_List.length(tokenBuffer) > 0) {
                console.log("ParsingBlock", "- Unexpected filled token buffer");
                return ;
              }
              var tokens = Belt_List.headExn(stack);
              var newState = /* ParsingBlock */{
                _0: {
                  hd: {
                    TAG: /* Block */2,
                    _0: blockTokens
                  },
                  tl: tokens._0
                }
              };
              _stack = Belt_List.tailExn(stack);
              _expressionTokens = otherTokens;
              _state = newState;
              continue ;
          default:
            
        }
      } else if (currentToken.TAG === /* Word */1) {
        if (currentToken._0 === "if") {
          if (Belt_List.length(tokenBuffer) > 0) {
            console.log("ParsingBlock", "- Unexpected filled token buffer");
            return ;
          }
          var match = parseIfExpression(/* ParsingIfNoBracketYet */0, otherTokens, /* [] */0);
          if (match === undefined) {
            return ;
          }
          _expressionTokens = match.restOfTokens;
          _state = /* ParsingBlock */{
            _0: {
              hd: {
                TAG: /* IfExpression */0,
                _0: match.tokens
              },
              tl: blockTokens
            }
          };
          continue ;
        }
        if (Belt_List.length(tokenBuffer) > 0) {
          console.log("ParsingBlock", "- Unexpected filled token buffer");
          return ;
        }
        var match$1 = parseStatement({
              TAG: /* ParsingStatement */0,
              _0: 0
            }, {
              hd: currentToken,
              tl: otherTokens
            }, /* [] */0);
        if (match$1 === undefined) {
          return ;
        }
        _expressionTokens = match$1.restOfTokens;
        _state = /* ParsingBlock */{
          _0: {
            hd: {
              TAG: /* Statement */1,
              _0: match$1.tokens
            },
            tl: blockTokens
          }
        };
        continue ;
      }
      console.log("ParsingBlock", "- Unexpected token:", parsedTokenToString(currentToken));
      return ;
    }
    console.log("End of tokens");
    var match$2 = Belt_List.length(stack);
    if (match$2 !== 0) {
      return ;
    } else {
      return {
              tokens: Belt_List.reverse(state._0)
            };
    }
  };
}

console.log(Belt_List.toArray(parseExpressionTokens(parsed).tokens).map(function (token) {
            switch (token.TAG | 0) {
              case /* IfExpression */0 :
                  return "If";
              case /* Statement */1 :
                  return "Statement";
              case /* Block */2 :
                  return "Block";
              
            }
          }).join("\n"));

exports.code = code;
exports.isNumeric = isNumeric;
exports.isAlphabetical = isAlphabetical;
exports.isAlphanumeric = isAlphanumeric;
exports.strToTokenList = strToTokenList;
exports.expressionStateToString = expressionStateToString;
exports.isTerminatingCharacter = isTerminatingCharacter;
exports.isOperator = isOperator;
exports.parsedTokenToString = parsedTokenToString;
exports.parseExpression = parseExpression;
exports.parsed = parsed;
exports.parserStateToString = parserStateToString;
exports.ifParserStateToString = ifParserStateToString;
exports.parseIfExpression = parseIfExpression;
exports.statementParserStateToString = statementParserStateToString;
exports.parseStatement = parseStatement;
exports.parseExpressionTokens = parseExpressionTokens;
/* parsed Not a pure module */
