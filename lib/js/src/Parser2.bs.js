// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");

var code = "\nif (WorldGen.destroyObject && false || true)\n        {\n            return;\n        }\n        let y: int = j - (world.getTile({ x: i, y: j }).frameY / 18) as int;\n        let fX: int = world.getTile({ x: i, y: j }).frameX as int;\n        let fX2: int = 0;\n        let a: string = \"hello\";\n        while (fX >= 5000)\n        {\n            fX -= 5000;\n            fX2++;\n        }\n        if (fX2 != 0)\n        {\n            fX = (fX2 - 1) * 18;\n        }\n         for (int f2 = 0; f2 < h; f2++)\n            {\n                if (world.getTile({ x: x, y: y + f2 }).type == (ushort)type)\n                {\n                    WorldGen.KillTile(x, y + f2, false, false, false);\n                }\n            }\n";

function isNumeric(character) {
  switch (character) {
    case "0" :
    case "1" :
    case "2" :
    case "3" :
    case "4" :
    case "5" :
    case "6" :
    case "7" :
    case "8" :
    case "9" :
        return true;
    default:
      return false;
  }
}

function isAlphabetical(character) {
  switch (character) {
    case "A" :
    case "B" :
    case "C" :
    case "D" :
    case "E" :
    case "F" :
    case "G" :
    case "H" :
    case "I" :
    case "J" :
    case "K" :
    case "L" :
    case "M" :
    case "N" :
    case "O" :
    case "P" :
    case "Q" :
    case "R" :
    case "S" :
    case "T" :
    case "U" :
    case "V" :
    case "W" :
    case "X" :
    case "Y" :
    case "Z" :
    case "a" :
    case "b" :
    case "c" :
    case "d" :
    case "e" :
    case "f" :
    case "g" :
    case "h" :
    case "i" :
    case "j" :
    case "k" :
    case "l" :
    case "m" :
    case "n" :
    case "o" :
    case "p" :
    case "q" :
    case "r" :
    case "s" :
    case "t" :
    case "u" :
    case "v" :
    case "w" :
    case "x" :
    case "y" :
    case "z" :
        return true;
    default:
      return false;
  }
}

function isAlphanumeric(character) {
  if (isNumeric(character)) {
    return true;
  } else {
    return isAlphabetical(character);
  }
}

function strToTokenList(codeStr) {
  return Belt_List.fromArray(Array.from(codeStr, (function (x) {
                    return x;
                  })));
}

function expressionStateToString(state) {
  if (typeof state === "number") {
    switch (state) {
      case /* Processing */0 :
          return "Processing";
      case /* ProcessingAnd */1 :
          return "ProcessingAnd";
      case /* ProcessingOr */2 :
          return "ProcessingOr";
      
    }
  } else {
    switch (state.TAG | 0) {
      case /* ProcessingWord */0 :
          return "ProcessingWord";
      case /* ProcessingNumber */1 :
          return "ProcessingNumber";
      case /* ProcessingString */2 :
          return "ProcessingString";
      
    }
  }
}

function isTerminatingCharacter(terminationList, character) {
  console.log("isTerminatingCharacter", terminationList, character);
  var result = Belt_List.someU(Belt_Option.mapWithDefaultU(terminationList, /* [] */0, (function (terminationToken) {
              return terminationToken;
            })), (function (terminationToken) {
          return character === terminationToken;
        }));
  console.log(result);
  return result;
}

function isOperator(character) {
  switch (character) {
    case "!" :
    case "*" :
    case "+" :
    case "-" :
    case "/" :
    case "<" :
    case "=" :
    case ">" :
        return true;
    default:
      return false;
  }
}

function parsedTokenToString(token) {
  if (typeof token === "number") {
    switch (token) {
      case /* OpenBracket */0 :
          return "OpenBracket";
      case /* CloseBracket */1 :
          return "CloseBracket";
      case /* Dot */2 :
          return "Dot";
      case /* Comma */3 :
          return "Comma";
      case /* Semicolon */4 :
          return "Semicolon";
      case /* Colon */5 :
          return "Colon";
      case /* OpenBrace */6 :
          return "OpenBrace";
      case /* CloseBrace */7 :
          return "CloseBrace";
      case /* And */8 :
          return "And";
      case /* Or */9 :
          return "Or";
      case /* BitwiseAnd */10 :
          return "BitwiseAnd";
      case /* BitwiseOr */11 :
          return "BitwiseOr";
      
    }
  } else {
    switch (token.TAG | 0) {
      case /* Operator */0 :
          return "Operator(" + token._0 + ")";
      case /* Word */1 :
          return "Word(" + token._0 + ")";
      case /* String */2 :
          return "String(" + token._0 + ")";
      case /* Number */3 :
          return "Number(" + token._0 + ")";
      case /* Function */4 :
          return "Function(" + token._0 + ")";
      
    }
  }
}

function parseExpression(expression) {
  var _state = /* Processing */0;
  var _expression = expression;
  var _parsedTokens = /* [] */0;
  while(true) {
    var parsedTokens = _parsedTokens;
    var expression$1 = _expression;
    var state = _state;
    if (!expression$1) {
      return {
              tokens: parsedTokens,
              remainingCode: /* [] */0
            };
    }
    var otherTokens = expression$1.tl;
    var currentToken = expression$1.hd;
    if (typeof state === "number") {
      switch (state) {
        case /* Processing */0 :
            if (isAlphabetical(currentToken)) {
              _expression = otherTokens;
              _state = {
                TAG: /* ProcessingWord */0,
                _0: currentToken
              };
              continue ;
            }
            if (isNumeric(currentToken)) {
              _expression = otherTokens;
              _state = {
                TAG: /* ProcessingNumber */1,
                _0: currentToken
              };
              continue ;
            }
            if (isOperator(currentToken)) {
              _parsedTokens = {
                hd: {
                  TAG: /* Operator */0,
                  _0: currentToken
                },
                tl: parsedTokens
              };
              _expression = otherTokens;
              _state = /* Processing */0;
              continue ;
            }
            switch (currentToken) {
              case "\n" :
              case " " :
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case "\"" :
                  _expression = otherTokens;
                  _state = {
                    TAG: /* ProcessingString */2,
                    _0: ""
                  };
                  continue ;
              case "&" :
                  _expression = otherTokens;
                  _state = /* ProcessingAnd */1;
                  continue ;
              case "(" :
                  _parsedTokens = {
                    hd: /* OpenBracket */0,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case ")" :
                  _parsedTokens = {
                    hd: /* CloseBracket */1,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case "," :
                  _parsedTokens = {
                    hd: /* Comma */3,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case "." :
                  _parsedTokens = {
                    hd: /* Dot */2,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case ":" :
                  _parsedTokens = {
                    hd: /* Colon */5,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case ";" :
                  _parsedTokens = {
                    hd: /* Semicolon */4,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case "{" :
                  _parsedTokens = {
                    hd: /* OpenBrace */6,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              case "|" :
                  _expression = otherTokens;
                  _state = /* ProcessingOr */2;
                  continue ;
              case "}" :
                  _parsedTokens = {
                    hd: /* CloseBrace */7,
                    tl: parsedTokens
                  };
                  _expression = otherTokens;
                  _state = /* Processing */0;
                  continue ;
              default:
                console.log("Unexpected token: '" + currentToken + "'");
                console.log("in state:", expressionStateToString(state));
                return ;
            }
        case /* ProcessingAnd */1 :
            if (currentToken === "&") {
              _parsedTokens = {
                hd: /* And */8,
                tl: parsedTokens
              };
              _expression = otherTokens;
              _state = /* Processing */0;
              continue ;
            }
            _parsedTokens = {
              hd: /* BitwiseAnd */10,
              tl: parsedTokens
            };
            _expression = otherTokens;
            _state = /* Processing */0;
            continue ;
        case /* ProcessingOr */2 :
            if (currentToken === "|") {
              _parsedTokens = {
                hd: /* Or */9,
                tl: parsedTokens
              };
              _expression = otherTokens;
              _state = /* Processing */0;
              continue ;
            }
            _parsedTokens = {
              hd: /* BitwiseOr */11,
              tl: parsedTokens
            };
            _expression = otherTokens;
            _state = /* Processing */0;
            continue ;
        
      }
    } else {
      switch (state.TAG | 0) {
        case /* ProcessingWord */0 :
            var word = state._0;
            if (isAlphanumeric(currentToken)) {
              _expression = otherTokens;
              _state = {
                TAG: /* ProcessingWord */0,
                _0: word + currentToken
              };
              continue ;
            }
            _parsedTokens = {
              hd: {
                TAG: /* Word */1,
                _0: word
              },
              tl: parsedTokens
            };
            _expression = {
              hd: currentToken,
              tl: otherTokens
            };
            _state = /* Processing */0;
            continue ;
        case /* ProcessingNumber */1 :
            var number = state._0;
            if (isNumeric(currentToken)) {
              _expression = otherTokens;
              _state = {
                TAG: /* ProcessingNumber */1,
                _0: number + currentToken
              };
              continue ;
            }
            _parsedTokens = {
              hd: {
                TAG: /* Number */3,
                _0: number
              },
              tl: parsedTokens
            };
            _expression = {
              hd: currentToken,
              tl: otherTokens
            };
            _state = /* Processing */0;
            continue ;
        case /* ProcessingString */2 :
            var word$1 = state._0;
            if (currentToken === "\"") {
              _parsedTokens = {
                hd: {
                  TAG: /* String */2,
                  _0: word$1
                },
                tl: parsedTokens
              };
              _expression = otherTokens;
              _state = /* Processing */0;
              continue ;
            }
            _expression = otherTokens;
            _state = {
              TAG: /* ProcessingString */2,
              _0: word$1 + currentToken
            };
            continue ;
        
      }
    }
  };
}

var parsed = Belt_List.reverse(parseExpression(Belt_List.fromArray(Array.from(code, (function (x) {
                    return x;
                  })))).tokens);

console.log(Belt_Array.joinWithU(Belt_Array.mapU(Belt_List.toArray(parsed), parsedTokenToString), " ", (function (a) {
            return a;
          })));

console.log(Belt_List.reduceU(parsed, "", (function (acc, token) {
            var tmp;
            if (typeof token === "number") {
              switch (token) {
                case /* OpenBracket */0 :
                    tmp = "(";
                    break;
                case /* CloseBracket */1 :
                    tmp = ")";
                    break;
                case /* Dot */2 :
                    tmp = ".";
                    break;
                case /* Comma */3 :
                    tmp = ", ";
                    break;
                case /* Semicolon */4 :
                    tmp = ";\n";
                    break;
                case /* Colon */5 :
                    tmp = ":";
                    break;
                case /* OpenBrace */6 :
                    tmp = "\n{\n";
                    break;
                case /* CloseBrace */7 :
                    tmp = "\n}\n";
                    break;
                case /* And */8 :
                    tmp = "&&";
                    break;
                case /* Or */9 :
                    tmp = "||";
                    break;
                case /* BitwiseAnd */10 :
                    tmp = "&";
                    break;
                case /* BitwiseOr */11 :
                    tmp = "|";
                    break;
                
              }
            } else {
              switch (token.TAG | 0) {
                case /* Operator */0 :
                    tmp = token._0 + " ";
                    break;
                case /* Word */1 :
                    tmp = token._0 + " ";
                    break;
                case /* String */2 :
                    tmp = "\"" + token._0 + "\"";
                    break;
                case /* Number */3 :
                case /* Function */4 :
                    tmp = token._0;
                    break;
                
              }
            }
            return acc + tmp;
          })));

function parserStateToString(parserState) {
  if (typeof parserState === "number") {
    return "ParseIfNoBracketYet";
  }
  switch (parserState.TAG | 0) {
    case /* ParsingTopLevel */0 :
        return "ParsingTopLevel";
    case /* ParsingIf */1 :
        return "ParsingIf(" + String(parserState._0) + ")";
    case /* ParsingIfBody */2 :
        return "ParsingIfBody";
    case /* ParsingBlock */3 :
        return "ParsingBlock";
    
  }
}

function parseIfExpression(_state, _expressionTokens, _tokenBuffer) {
  while(true) {
    var tokenBuffer = _tokenBuffer;
    var expressionTokens = _expressionTokens;
    var state = _state;
    if (!expressionTokens) {
      return ;
    }
    var otherTokens = expressionTokens.tl;
    var currentToken = expressionTokens.hd;
    if (state) {
      var nestedBracketCount = state._0;
      if (typeof currentToken === "number") {
        if (currentToken !== 1) {
          if (currentToken !== 0) {
            _expressionTokens = otherTokens;
            continue ;
          }
          _tokenBuffer = {
            hd: currentToken,
            tl: tokenBuffer
          };
          _expressionTokens = otherTokens;
          _state = /* ParsingIf */{
            _0: nestedBracketCount + 1 | 0
          };
          continue ;
        }
        if (nestedBracketCount === 0) {
          return tokenBuffer;
        }
        _expressionTokens = otherTokens;
        _state = /* ParsingIf */{
          _0: nestedBracketCount - 1 | 0
        };
        continue ;
      }
      _expressionTokens = otherTokens;
      continue ;
    }
    if (currentToken === 0) {
      _expressionTokens = otherTokens;
      _state = /* ParsingIf */{
        _0: 0
      };
      continue ;
    }
    throw {
          RE_EXN_ID: "Match_failure",
          _1: [
            "Parser2.res",
            287,
            48
          ],
          Error: new Error()
        };
  };
}

function parseExpressionTokens(expressionTokens) {
  var _state = {
    TAG: /* ParsingTopLevel */0,
    _0: /* [] */0
  };
  var _expressionTokens = expressionTokens;
  var _stack = /* [] */0;
  var _tokenBuffer = /* [] */0;
  while(true) {
    var tokenBuffer = _tokenBuffer;
    var stack = _stack;
    var expressionTokens$1 = _expressionTokens;
    var state = _state;
    if (!expressionTokens$1) {
      return ;
    }
    var otherTokens = expressionTokens$1.tl;
    var currentToken = expressionTokens$1.hd;
    if (typeof state === "number") {
      if (currentToken === 0) {
        _expressionTokens = otherTokens;
        _state = {
          TAG: /* ParsingIf */1,
          _0: 0
        };
        continue ;
      }
      
    } else {
      switch (state.TAG | 0) {
        case /* ParsingTopLevel */0 :
            if (typeof currentToken !== "number" && currentToken.TAG === /* Word */1 && currentToken._0 === "if") {
              _expressionTokens = otherTokens;
              _state = /* ParsingIfNoBracketYet */0;
              continue ;
            }
            break;
        case /* ParsingIf */1 :
            var nestedBracketCount = state._0;
            if (typeof currentToken === "number") {
              if (currentToken !== 1) {
                if (currentToken !== 0) {
                  _expressionTokens = otherTokens;
                  continue ;
                }
                _tokenBuffer = {
                  hd: currentToken,
                  tl: tokenBuffer
                };
                _expressionTokens = otherTokens;
                _state = {
                  TAG: /* ParsingIf */1,
                  _0: nestedBracketCount + 1 | 0
                };
                continue ;
              }
              if (nestedBracketCount !== 0) {
                _expressionTokens = otherTokens;
                _state = {
                  TAG: /* ParsingIf */1,
                  _0: nestedBracketCount - 1 | 0
                };
                continue ;
              }
              _tokenBuffer = /* [] */0;
              _expressionTokens = otherTokens;
              _state = {
                TAG: /* ParsingIfBody */2,
                _0: Belt_List.reverse(tokenBuffer)
              };
              continue ;
            }
            _expressionTokens = otherTokens;
            continue ;
        case /* ParsingIfBody */2 :
            if (typeof currentToken === "number") {
              var exit = 0;
              if (!(currentToken !== 4 && currentToken !== 6)) {
                exit = 2;
              }
              if (exit === 2) {
                _stack = {
                  hd: state,
                  tl: stack
                };
                _expressionTokens = otherTokens;
                _state = {
                  TAG: /* ParsingBlock */3,
                  _0: /* [] */0
                };
                continue ;
              }
              
            }
            break;
        case /* ParsingBlock */3 :
            break;
        
      }
    }
    console.log(parserStateToString(state), "- Unexpected token:", parsedTokenToString(currentToken));
    return ;
  };
}

parseExpressionTokens(parsed);

exports.code = code;
exports.isNumeric = isNumeric;
exports.isAlphabetical = isAlphabetical;
exports.isAlphanumeric = isAlphanumeric;
exports.strToTokenList = strToTokenList;
exports.expressionStateToString = expressionStateToString;
exports.isTerminatingCharacter = isTerminatingCharacter;
exports.isOperator = isOperator;
exports.parsedTokenToString = parsedTokenToString;
exports.parseExpression = parseExpression;
exports.parsed = parsed;
exports.parserStateToString = parserStateToString;
exports.parseIfExpression = parseIfExpression;
exports.parseExpressionTokens = parseExpressionTokens;
/* parsed Not a pure module */
